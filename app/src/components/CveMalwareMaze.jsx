import { useEffect, useMemo, useRef, useState } from "react";

const GRID_SIZE = 5;
const MAX_WALLS = 6;
const stopWords = new Set([
  "reverse",
  "engineering",
  "from",
  "with",
  "into",
  "watchguard",
  "firebox",
  "kernel",
  "linux",
  "audit",
  "transient",
  "scheduler",
  "attacks",
  "understanding",
  "cve",
  "blog",
  "server",
  "tiny",
  "fake",
]);

const pickKeyword = (text) => {
  const cleaned = (text || "").toLowerCase().replace(/[^a-z0-9\s]/g, " ");
  const words = cleaned.split(/\s+/).filter(Boolean);
  const keyword = words.find((word) => word.length > 4 && !stopWords.has(word));
  return keyword ? keyword.toUpperCase() : "VECTOR";
};

const pickEntry = (entries) => {
  if (!entries.length) {
    return {
      id: "UNKNOWN",
      title: "Unknown cluster",
      year: "Unknown",
      severity: "Unknown",
      summary: "",
      href: "",
    };
  }
  return entries[Math.floor(Math.random() * entries.length)];
};

const keyFor = (row, col) => `${row}-${col}`;

const withinBounds = (row, col) => row >= 0 && col >= 0 && row < GRID_SIZE && col < GRID_SIZE;

const neighbors = (row, col) => [
  { row: row - 1, col },
  { row: row + 1, col },
  { row, col: col - 1 },
  { row, col: col + 1 },
];

const hasPath = (start, target, walls) => {
  const queue = [start];
  const visited = new Set([keyFor(start.row, start.col)]);
  while (queue.length) {
    const current = queue.shift();
    if (current.row === target.row && current.col === target.col) return true;
    neighbors(current.row, current.col).forEach((next) => {
      const key = keyFor(next.row, next.col);
      if (!withinBounds(next.row, next.col)) return;
      if (walls.has(key) || visited.has(key)) return;
      visited.add(key);
      queue.push(next);
    });
  }
  return false;
};

const buildMaze = (entries) => {
  const entry = pickEntry(entries);
  const start = { row: GRID_SIZE - 1, col: 0 };
  let target = { row: Math.floor(Math.random() * GRID_SIZE), col: Math.floor(Math.random() * GRID_SIZE) };
  while (target.row === start.row && target.col === start.col) {
    target = { row: Math.floor(Math.random() * GRID_SIZE), col: Math.floor(Math.random() * GRID_SIZE) };
  }
  let walls = new Set();
  for (let attempt = 0; attempt < 24; attempt += 1) {
    const nextWalls = new Set();
    const candidates = [];
    for (let row = 0; row < GRID_SIZE; row += 1) {
      for (let col = 0; col < GRID_SIZE; col += 1) {
        const key = keyFor(row, col);
        if (key === keyFor(start.row, start.col) || key === keyFor(target.row, target.col)) continue;
        candidates.push(key);
      }
    }
    while (nextWalls.size < MAX_WALLS && candidates.length) {
      const idx = Math.floor(Math.random() * candidates.length);
      const [picked] = candidates.splice(idx, 1);
      nextWalls.add(picked);
    }
    if (hasPath(start, target, nextWalls)) {
      walls = nextWalls;
      break;
    }
  }
  return { entry, start, target, walls };
};

const initialLog = () => [
  { type: "system", text: "MALWARE MAZE // Wireframe grid online." },
  { type: "system", text: "Navigate the maze and quarantine the infected node." },
];

const directionHint = (from, to) => {
  const vertical = to.row < from.row ? "north" : to.row > from.row ? "south" : "aligned";
  const horizontal = to.col < from.col ? "west" : to.col > from.col ? "east" : "aligned";
  if (vertical === "aligned" && horizontal === "aligned") return "on target";
  if (vertical === "aligned") return horizontal;
  if (horizontal === "aligned") return vertical;
  return `${vertical}-${horizontal}`;
};

const heatFromDistance = (distance) => {
  if (distance === 0) return "direct";
  if (distance <= 2) return "hot";
  if (distance <= 4) return "warm";
  if (distance <= 6) return "cool";
  return "cold";
};

export default function CveMalwareMaze({ entries = [] }) {
  const [maze, setMaze] = useState(() => buildMaze(entries));
  const [position, setPosition] = useState(() => maze.start);
  const [visited, setVisited] = useState(() => new Set([keyFor(maze.start.row, maze.start.col)]));
  const [moves, setMoves] = useState(0);
  const [status, setStatus] = useState("active");
  const [log, setLog] = useState(() => initialLog());
  const logRef = useRef(null);

  const intel = useMemo(
    () => ({
      year: maze.entry?.year || "Unknown",
      severity: maze.entry?.severity || "Unknown",
      keyword: pickKeyword(`${maze.entry?.title || ""} ${maze.entry?.summary || ""}`),
    }),
    [maze]
  );

  useEffect(() => {
    if (!logRef.current) return;
    logRef.current.scrollTop = logRef.current.scrollHeight;
  }, [log]);

  useEffect(() => {
    if (!entries.length) return;
    const nextMaze = buildMaze(entries);
    setMaze(nextMaze);
    setPosition(nextMaze.start);
    setVisited(new Set([keyFor(nextMaze.start.row, nextMaze.start.col)]));
    setMoves(0);
    setStatus("active");
    setLog([...initialLog(), { type: "system", text: "New maze instance deployed." }]);
  }, [entries]);

  const appendLog = (text, type = "info") => {
    setLog((prev) => [...prev, { type, text }]);
  };

  const resetMaze = () => {
    const nextMaze = buildMaze(entries);
    setMaze(nextMaze);
    setPosition(nextMaze.start);
    setVisited(new Set([keyFor(nextMaze.start.row, nextMaze.start.col)]));
    setMoves(0);
    setStatus("active");
    setLog([...initialLog(), { type: "system", text: "Maze rebooted." }]);
  };

  const move = (deltaRow, deltaCol) => {
    if (status === "found") return;
    const nextRow = position.row + deltaRow;
    const nextCol = position.col + deltaCol;
    if (!withinBounds(nextRow, nextCol)) {
      appendLog("Boundary reached. Movement blocked.", "warning");
      return;
    }
    const key = keyFor(nextRow, nextCol);
    if (maze.walls.has(key)) {
      appendLog("Firewall ahead. Choose another route.", "warning");
      return;
    }
    setPosition({ row: nextRow, col: nextCol });
    setVisited((prev) => {
      const next = new Set(prev);
      next.add(key);
      return next;
    });
    setMoves((prev) => prev + 1);
    if (nextRow === maze.target.row && nextCol === maze.target.col) {
      setStatus("found");
      appendLog("Infected node contained.", "success");
      appendLog(`Identity confirmed: ${maze.entry?.id || "Unknown"}.`, "success");
    }
  };

  const scan = () => {
    if (status === "found") return;
    const distance =
      Math.abs(position.row - maze.target.row) + Math.abs(position.col - maze.target.col);
    const heat = heatFromDistance(distance);
    const direction = directionHint(position, maze.target);
    appendLog(`Scan: signal ${heat}. Direction ${direction}.`, "info");
  };

  const probe = () => {
    if (status === "found") return;
    const blocked = neighbors(position.row, position.col).filter((next) => {
      if (!withinBounds(next.row, next.col)) return true;
      return maze.walls.has(keyFor(next.row, next.col));
    }).length;
    appendLog(`Probe: ${blocked} firewall blocks adjacent lanes.`, "info");
  };

  const isVisited = (row, col) => visited.has(keyFor(row, col));
  const isWall = (row, col) => maze.walls.has(keyFor(row, col));
  const isPlayer = (row, col) => position.row === row && position.col === col;
  const isTarget = (row, col) =>
    status === "found" && maze.target.row === row && maze.target.col === col;

  return (
    <div className="maze-layout">
      <div className="maze-panel">
        <div className="maze-header">
          <div>
            <div className="maze-title">Malware Maze</div>
            <div className="maze-subtitle">Navigate the grid and lock down the infection.</div>
          </div>
          <div className={`maze-status ${status}`}>{status === "found" ? "CONTAINED" : "ACTIVE"}</div>
        </div>
        <div className="maze-intel">
          <div className="maze-intel-row">
            <span>Codename</span>
            <span>{intel.keyword}</span>
          </div>
          <div className="maze-intel-row">
            <span>Year</span>
            <span>{intel.year}</span>
          </div>
          <div className="maze-intel-row">
            <span>Severity</span>
            <span>{intel.severity}</span>
          </div>
          <div className="maze-intel-row">
            <span>Moves</span>
            <span>{moves}</span>
          </div>
        </div>
        <div className="maze-controls">
          <div className="maze-dpad">
            <button type="button" onClick={() => move(-1, 0)} aria-label="Move north">
              ^
            </button>
            <div className="maze-dpad-middle">
              <button type="button" onClick={() => move(0, -1)} aria-label="Move west">
                &lt;
              </button>
              <button type="button" onClick={() => move(0, 1)} aria-label="Move east">
                &gt;
              </button>
            </div>
            <button type="button" onClick={() => move(1, 0)} aria-label="Move south">
              v
            </button>
          </div>
          <div className="maze-actions">
            <button className="pill" type="button" onClick={scan}>
              Scan
            </button>
            <button className="pill" type="button" onClick={probe}>
              Probe
            </button>
            <button className="pill" type="button" onClick={resetMaze}>
              New maze
            </button>
            {status === "found" && maze.entry?.href && (
              <a className="button primary" href={maze.entry.href} target="_blank" rel="noreferrer">
                Open report
              </a>
            )}
          </div>
        </div>
        <div className="maze-log" ref={logRef}>
          {log.map((line, idx) => (
            <div key={`${line.type}-${idx}`} className={`maze-line ${line.type}`}>
              {line.text}
            </div>
          ))}
        </div>
        {status === "found" && (
          <div className="maze-result">
            <div className="maze-result-title">Node quarantined</div>
            <div className="maze-result-id">{maze.entry?.id || "Unknown"}</div>
            <div className="maze-result-text">{maze.entry?.title}</div>
          </div>
        )}
      </div>
      <div className="maze-stage">
        <div className="maze-grid">
          {Array.from({ length: GRID_SIZE }).map((_, row) =>
            Array.from({ length: GRID_SIZE }).map((_, col) => (
              <div
                key={`${row}-${col}`}
                className={[
                  "maze-cell",
                  isVisited(row, col) ? "visited" : "",
                  isWall(row, col) ? "wall" : "",
                  isPlayer(row, col) ? "player" : "",
                  isTarget(row, col) ? "target" : "",
                ]
                  .filter(Boolean)
                  .join(" ")}
              />
            ))
          )}
        </div>
      </div>
    </div>
  );
}
